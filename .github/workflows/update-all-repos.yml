name: Update All Repos JSON

on:
  schedule:
    # 每天凌晨 00:00 (UTC) 运行一次，如果你想每12小时运行一次，可以设置 '0 */12 * * *'
    # 注意：GitHub Actions 的 cron 表达式基于 UTC 时间
    - cron: '0 0 * * *'
  workflow_dispatch:  # 允许手动触发

jobs:
  update-kazumi:
    runs-on: ubuntu-latest
    permissions:
      contents: write # 授予写入权限以更新文件和推送

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests PyGithub

      - name: Check releases and update kazumi.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO_OWNER: Predidit
          REPO_NAME: Kazumi
          JSON_FILE: kazumi.json
          INITIAL_JSON_FUNCTION: "None" # 指示不需要创建初始JSON
        run: |
          cat > update_repo_json.py << 'EOF'
          import json
          import os
          from datetime import datetime
          from github import Github
          import requests

          def get_file_size(url):
              response = requests.head(url)
              return int(response.headers.get('content-length', 0))

          # 此函数现在是通用的，并且根据环境变量决定是否使用
          def create_initial_json_placeholder():
              # 如果在 Workflow 中配置 'INITIAL_JSON_FUNCTION: "None"'，则此函数不会被调用
              # 实际的创建逻辑会放在对应的 Job 中，如果需要的话
              pass

          def main():
              github_token = os.environ['GITHUB_TOKEN']
              repo_owner = os.environ['REPO_OWNER']
              repo_name = os.environ['REPO_NAME']
              json_file_name = os.environ['JSON_FILE']
              initial_json_func_name = os.environ.get('INITIAL_JSON_FUNCTION', 'None')

              g = Github(github_token)
              repo = g.get_repo(f"{repo_owner}/{repo_name}")
              
              latest_release = repo.get_latest_release()
              
              ipa_asset = None
              for asset in latest_release.get_assets():
                  if asset.name.endswith('.ipa'):
                      ipa_asset = asset
                      break
              
              if not ipa_asset:
                  print(f"[{json_file_name}] No IPA file found in latest release for {repo_owner}/{repo_name}. Skipping update.")
                  return

              source_data = {}
              if os.path.exists(json_file_name):
                  try:
                      with open(json_file_name, 'r', encoding='utf-8') as f:
                          source_data = json.load(f)
                      print(f"[{json_file_name}] Loaded existing data.")
                  except (FileNotFoundError, json.JSONDecodeError):
                      print(f"[{json_file_name}] Existing {json_file_name} is invalid or not found. Attempting to create new.")
                      if initial_json_func_name != "None":
                          print(f"[{json_file_name}] Calling initial JSON function: {initial_json_func_name}")
                          # 这里需要根据实际情况调用一个函数
                          # 由于Python脚本是通用的，这里需要更巧妙处理初始JSON的创建
                          # 对于Kazumi，我们假设文件总是存在且有效，或不需要从头创建
                          pass # Kazumi不从头创建json
                      else:
                          print(f"[{json_file_name}] No initial JSON function specified for {json_file_name}. Cannot create from scratch.")
                          return
              else: # 文件不存在
                  print(f"[{json_file_name}] {json_file_name} not found locally.")
                  if initial_json_func_name != "None":
                      print(f"[{json_file_name}] Calling initial JSON function: {initial_json_func_name}")
                      # 对于Kazumi，我们不应该进入这里，因为它依赖于 existing JSON
                      pass
                  else:
                      print(f"[{json_file_name}] No initial JSON function specified and {json_file_name} does not exist. Cannot proceed.")
                      return

              # 假设 kazumi.json 的结构是 apps[0]
              if 'apps' not in source_data or not source_data['apps']:
                  print(f"[{json_file_name}] 'apps' array not found or is empty in {json_file_name}.")
                  return

              app_data = source_data['apps'][0]
              
              app_data.update({
                  'version': latest_release.tag_name.lstrip('v'),
                  'versionDate': latest_release.published_at.strftime("%Y-%m-%dT%H:%M:%SZ"),
                  'downloadURL': ipa_asset.browser_download_url,
                  'size': ipa_asset.size,
                  'versionDescription': latest_release.body
              })
              print(f"[{json_file_name}] Updated version to: {app_data['version']}")

              with open(json_file_name, 'w', encoding='utf-8') as f:
                  json.dump(source_data, f, ensure_ascii=False, indent=2)
              print(f"[{json_file_name}] Successfully updated {json_file_name}")

          if __name__ == '__main__':
              main()
          EOF

          python update_repo_json.py

      - name: Commit changes for Kazumi
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add kazumi.json
          git diff --quiet && git diff --staged --quiet || git commit -m "chore: update kazumi.json with latest release info [skip ci]"

      - name: Push changes for Kazumi
        run: git push

  update-piliplus:
    runs-on: ubuntu-latest
    permissions:
      contents: write # 授予写入权限以更新文件和推送

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests PyGithub

      - name: Check releases and update piliplus.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO_OWNER: bggRGjQaUbCoE
          REPO_NAME: PiliPlus
          JSON_FILE: piliplus.json
          # 如果 piliplus.json 不存在，我们希望它能被创建
          INITIAL_JSON_FUNCTION: "create_initial_piliplus_json"
        run: |
          cat > update_repo_json.py << 'EOF'
          import json
          import os
          from datetime import datetime
          from github import Github # Auth from github is now part of Github init itself
          import requests

          def get_file_size(url):
              response = requests.head(url)
              return int(response.headers.get('content-length', 0))

          def create_initial_piliplus_json():
              return {
                  "identifier": "com.bggRGjQaUbCoE.PiliPlus",
                  "sourceURL": "https://raw.githubusercontent.com/bggRGjQaUbCoE/PiliPlus/main/piliplus.json",
                  "apps": [
                      {
                          "name": "PiliPlus",
                          "bundleIdentifier": "com.bggRGjQaUbCoE.PiliPlus",
                          "developerName": "bggRGjQaUbCoE",
                          "subtitle": "第三方哔哩哔哩客户端",
                          "localizedDescription": "PiliPlus 是一款第三方哔哩哔哩客户端，专为 iOS 设备打造。",
                          "iconURL": "https://raw.githubusercontent.com/bggRGjQaUbCoE/PiliPlus/main/assets/images/logo/logo.png",
                          "tintColor": "#FB7299",
                          "screenshotURLs": [
                              "https://raw.githubusercontent.com/bggRGjQaUbCoE/PiliPlus/main/assets/screenshots/home.png",
                              "https://raw.githubusercontent.com/bggRGjQaUbCoE/PiliPlus/main/assets/screenshots/main_screen.png"
                          ],
                          "version": "",
                          "versionDate": "",
                          "downloadURL": "",
                          "size": 0,
                          "versionDescription": ""
                      }
                  ]
              }

          def main():
              github_token = os.environ['GITHUB_TOKEN']
              repo_owner = os.environ['REPO_OWNER']
              repo_name = os.environ['REPO_NAME']
              json_file_name = os.environ['JSON_FILE']
              initial_json_func_name = os.environ.get('INITIAL_JSON_FUNCTION', 'None')

              g = Github(github_token) # Directly pass token
              repo = g.get_repo(f"{repo_owner}/{repo_name}")
              
              latest_release = repo.get_latest_release()
              
              ipa_asset = None
              for asset in latest_release.get_assets():
                  if asset.name.endswith('.ipa'):
                      ipa_asset = asset
                      break
              
              if not ipa_asset:
                  print(f"[{json_file_name}] No IPA file found in latest release for {repo_owner}/{repo_name}. Skipping update.")
                  return

              source_data = {}
              file_exists = os.path.exists(json_file_name)

              if file_exists:
                  try:
                      with open(json_file_name, 'r', encoding='utf-8') as f:
                          source_data = json.load(f)
                      print(f"[{json_file_name}] Loaded existing data.")
                  except json.JSONDecodeError:
                      print(f"[{json_file_name}] Existing {json_file_name} is invalid. Attempting to recreate.")
                      if initial_json_func_name == "create_initial_piliplus_json":
                          source_data = create_initial_piliplus_json()
                          print(f"[{json_file_name}] Recreated initial data from function.")
                      else:
                          print(f"[{json_file_name}] No valid initial JSON function for recreation. Aborting.")
                          return
              else: # 文件不存在
                  print(f"[{json_file_name}] {json_file_name} not found locally. Attempting to create new.")
                  if initial_json_func_name == "create_initial_piliplus_json":
                      source_data = create_initial_piliplus_json()
                      print(f"[{json_file_name}] Created initial data from function.")
                  else:
                      print(f"[{json_file_name}] No initial JSON function specified and {json_file_name} does not exist. Cannot proceed.")
                      return

              # 假设 piliplus.json 的结构也是 apps[0]
              if 'apps' not in source_data or not source_data['apps']:
                  print(f"[{json_file_name}] 'apps' array not found or is empty in {json_file_name}.")
                  return

              app_data = source_data['apps'][0]
              
              app_data.update({
                  'version': latest_release.tag_name.lstrip('v'),
                  'versionDate': latest_release.published_at.strftime("%Y-%m-%dT%H:%M:%SZ"),
                  'downloadURL': ipa_asset.browser_download_url,
                  'size': ipa_asset.size,
                  'versionDescription': latest_release.body
              })
              print(f"[{json_file_name}] Updated version to: {app_data['version']}")

              with open(json_file_name, 'w', encoding='utf-8') as f:
                  json.dump(source_data, f, ensure_ascii=False, indent=2)
              print(f"[{json_file_name}] Successfully updated {json_file_name}")

          if __name__ == '__main__':
              main()
          EOF

          python update_repo_json.py

      - name: Commit changes for PiliPlus
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add piliplus.json
          git diff --quiet && git diff --staged --quiet || git commit -m "chore: update piliplus.json with latest release info [skip ci]"

      - name: Push changes for PiliPlus
        run: git push
